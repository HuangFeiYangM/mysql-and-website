在 Go 语言中，**同一作用域内不能重复声明同名变量**，这是由语言设计规范强制要求的。你提供的代码中，三次使用短变量声明（`:=`）对 `goku` 进行定义，这违反了以下规则：

---

### **错误原因分析**
1. **重复声明冲突**
   Go 的短变量声明 `:=` 会同时完成**声明和初始化**，但同一作用域内不允许重复声明变量。以下代码试图在 `main` 函数作用域内多次声明 `goku`，导致编译错误：
   ```go
   func main() {
       goku := Saiyan{Name: "Goku", Power: 9000}  // 第一次声明 ✅
       goku := Saiyan{}                          // 第二次声明 ❌（重复）
       goku := Saiyan{"Goku", 9000}               // 第三次声明 ❌（重复）
   }
   ```

2. **作用域规则**
   Go 语言通过作用域隔离变量生命周期。若在**同一代码块内多次声明同名变量**，编译器会直接报错：
   ```text
   no new variables on left side of :=
   ```

---

### **正确写法**
根据需求选择以下方式：

#### 1. **声明后赋值**（推荐）
```go
func main() {
    // 声明变量（零值初始化）
    var goku Saiyan

    // 第一次赋值
    goku = Saiyan{Name: "Goku", Power: 9000}

    // 修改字段值
    goku.Power = 10000
}
```

#### 2. **短变量声明仅用一次**
```go
func main() {
    // 唯一一次短变量声明
    goku := Saiyan{Name: "Goku", Power: 9000}  // ✅

    // 后续通过赋值修改
    goku = Saiyan{Name: "Gohan"}  // 覆盖原有值
}
```

#### 3. **不同作用域允许同名变量**
```go
func main() {
    goku := Saiyan{Name: "Goku"}  // 外层作用域

    if true {
        goku := Saiyan{Name: "Gohan"}  // 内层作用域 ✅（允许）
        fmt.Println(goku.Name)         // 输出 "Gohan"
    }

    fmt.Println(goku.Name)  // 输出 "Goku"
}
```

---

### **关键规则总结**
| 场景                         | 是否允许 | 说明                                                                 |
|------------------------------|----------|----------------------------------------------------------------------|
| 同一作用域重复使用 `:=`      | ❌        | 触发编译错误                                                         |
| 外层作用域与内层作用域同名变量 | ✅        | 不同作用域变量独立（如 `if`/`for` 代码块内可重新声明）               |
| 先声明后赋值                  | ✅        | 使用 `var` 声明变量后，可通过 `=` 多次赋值                            |

---

### **语言设计原理**
Go 通过严格限制重复声明来避免以下问题：
1. **代码歧义**：防止意外覆盖变量导致逻辑错误。
2. **内存安全**：明确变量的生命周期，便于编译器优化。
3. **可读性**：减少同名变量干扰，提升代码清晰度。

若需深入理解，可参考 [Go 语言规范 - 变量声明](https://go.dev/ref/spec#Variable_declarations)。